# Note that old versions of git may not load configuration from ~/.config/git/config,
# loading only ~/.gitconfig.  I _strongly_ recommend installing latest git (>= 2.0)!

[alias]

    # SIMPLE "SHORTCUT" ALIASES

    ap = add --patch   # interactively select hunks to add, very useful
    au = add --update   # stage only tracked files - usually you want this rather than --all

    b = branch
    bv = branch --verbose --verbose   # lists branches with SHAs and upstreams

    c = checkout
    co = checkout   # I prefer 'c', but many people are used to 'co'

    # --verbose flag shows a preview of changes that will be committed when editing the
    # commit message - I no longer have to double-check with 'git diff' before committing!
    k = commit --verbose   # no git command starts with 'k', and 'k' matches pronunciation!
    ci = commit --verbose   # I prefer 'k', but many people are used to 'ci'
    kma = commit --all -m   # 'kma' instead of 'kam' because it's easier to type

    d = diff --color=always   # force coloring for use with less -R
    wd = diff --color=always --word-diff=color   # mnemonic: Word-Diff

    g = grep --color=always --line-number
    gh5 = grep --color=always --heading --context 5

    # always run log with --graph so that the topology will be visualized
    l = log --color=always --decorate --graph   # force coloring for use with less -R

    rb = rebase
    rbo = rebase --onto   # quite useful, see examples in 'git help rebase'
    rbi = rebase --interactive

    rs = reset
    rs1 = reset HEAD~1

    s = status --short   # I prefer terse output.  See also --branch option.
    st = status



    # PRETTY LOGS

    # Very helpful especially when you cannot run gitk.
    # The names are mnemonics based on common aliases of 'ls' command.
    # Partially inspired by http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs

    # log both HEAD and its upstream (if present)
    lu = !git log --color=always --decorate --graph \
    HEAD `git for-each-ref --format='%(upstream:short)' HEAD $(git symbolic-ref --quiet HEAD)`

    # basic one-line log, I use it all the time
    ls = !git lu --date=relative \
    --format=tformat:'%C(auto)%h%C(reset) -%C(auto)%d%C(reset) %s %C(dim)- %an, %ad%C(reset)'

    # as above, but includes all local and remote branches
    la = !git ls --branches --remotes

    # "Long" format - full commit message and summary of changes
    ll = !git lu --stat-graph-width=30 --stat-count=30 --date-order



    # MORE SOPHISTICATED ALIASES

    # "smart amend"
    #
    # Fixup a specified commit and use rebase to merge the fixup (like commit --amend,
    # but for commits before the currently checked-out one - see the description of
    # --fixup option in `git commit` manpage).  By default the fixup will incorporate
    # staged changes, but you can also use `-a` option (or specify paths), like with
    # `git commit` itself.
    # Don't use this if there was a merge after the commit to be amended.
    #
    fix = "!sh -c 'set -e; \
        commit_id=$(git rev-parse $1); \
        shift; \
        git commit --fixup $commit_id $@; \
        if ! git diff --quiet HEAD; then \
            dirtytree=1; \
            echo \"Stashing your other changes...\"; \
            git stash save \"Stashed before amending $commit_id\"; \
        fi; \
        git rebase --interactive --autosquash $commit_id~; \
        if [ -n \"$dirtytree\" ]; then \
            git stash pop; \
        fi' -"

    # trash - discard changes
    #
    # Use this command instead of `reset --hard`, as it makes it possible to undo
    # the trashing.  Right now this is implemented simply by using `stash` command,
    # so to bring back discarded changes you just do `git stash pop <stash>`.
    #
    # Useful options:
    #     -p    select which hunks to discard
    #     -u    also remove untracked files
    #     -a    also remove untracked and ignored files
    #
    # TODO:
    # - add support for trashing changes in indvidual files
    # - rewrite this as a standalone git command
    # - send a patch upstream?
    #
    trash = !sh -c 'git stash save "$@" "changes trashed on $(date +\"%Y-%m-%d %H:%M\")"' -



[color]
    ui = auto

[core]
    # display non-ASCII characters (e.g. Polish) instead of quoting them
    quotepath = false

[diff]
    # detect renamed files and show only actual differences between versions
    renames = copies

[merge]
    # in case of merge conflict also show common ancestor version
    conflictstyle = diff3

[push]
    default = simple

[rebase]
    # automatically process "fixup!" commits when rebasing interactively
    autosquash = true
